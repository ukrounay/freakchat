<!DOCTYPE html>
<html>
<head>

  <title>FreakChat</title>

  <link href="https://fonts.googleapis.com/css2?family=Noto+Sans&display=swap&subset=latin,latin-ext,cyrillic,cyrillic-ext" rel="stylesheet">
  <link rel="stylesheet" href="styles/base.css">

  <meta name="viewport" content="width=device-width, initial-scale=1.0">

</head>
<body>

  <div id="loginBox">
    <input id="loginUser" placeholder="Username" />
    <input id="loginPass" type="password" placeholder="Password" />
    <button onclick="login()">Log In</button>
  </div>

  <div id="chatUI" style="display:none;">

    <div class="chat-container">
      <header>
        <nav>
          <span class="logo">
            <span>freak</span>chat
          </span>
          <div>
            <button onclick="shareMessages()">Share Saved Messages</button>
          </div>
        </nav>
      </header>
      <div id="messages"></div>
      <div class="chat-input">
        <p>
          <textarea id="msgInput" placeholder="Type a message..."></textarea>
          <button onclick="sendMessage()">Send</button>
        </p>
        <p>
          <input type="file" id="imgInput" accept="image/*" />
          <button onclick="sendImage()">Send Image</button>
        </p>
      </div>
    </div>

  </div>

<script>





let currentUser = null;
const userCache = new Map();
const protocol = location.protocol === "https:" ? "wss" : "ws";
const socket = new WebSocket(`${protocol}://${location.host}`);
const dbName = "chatDB";
let db = null;
let savingEnabled = false;

const warnEl = document.createElement('div');
warnEl.style.background = "#ffcccc";
warnEl.style.padding = "10px";
warnEl.style.textAlign = "center";
warnEl.style.display = "none";
warnEl.textContent = "⚠️ IndexedDB not supported — messages won’t be saved locally.";
document.body.prepend(warnEl);

if (!window.indexedDB) {
  warnEl.style.display = "block";
} else {
  const request = indexedDB.open(dbName, 1);
  request.onupgradeneeded = event => {
    db = event.target.result;
    db.createObjectStore("messages", { keyPath: "id" });
  };
  request.onsuccess = () => {
    db = request.result;
    savingEnabled = true;
    loadAndRenderMessages();
  };
  request.onerror = () => warnEl.style.display = "block";
}


// Check if already signed in
fetch('/api/user', { credentials: 'include' })
  .then(res => res.json())
  .then(user => {
    if (!user || user.error) return;
    currentUser = user;
    userCache.set(user.username, user);
    document.getElementById('loginBox').style.display = 'none';
    document.getElementById('chatUI').style.display = 'block';
  })
  .catch(err => console.warn("Auto-login failed:", err));



function login() {
  const username = document.getElementById('loginUser').value;
  const password = document.getElementById('loginPass').value;

  fetch('/api/login', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    credentials: 'include',
    body: JSON.stringify({ username, password })
  })
  .then(res => res.json())
  .then(user => {
    if (user.error) return alert(user.error);
    currentUser = user;
    userCache.set(user.username, user);
    document.getElementById('loginBox').style.display = 'none';
    document.getElementById('chatUI').style.display = 'block';
  })
  .catch(() => alert('Login failed.'));
}


function getUser(username) {
  if (userCache.has(username)) return Promise.resolve(userCache.get(username));
  return fetch('/api/user/'+ encodeURIComponent(username))
    .then(res => res.json())
    .then(user => {
      userCache.set(username, user);
      return user;
    });
}

function loadAndRenderMessages() {
  if (!savingEnabled) return;
  const tx = db.transaction("messages", "readonly");
  const store = tx.objectStore("messages");
  const req = store.getAll();
  req.onsuccess = () => renderMessages(req.result);
}

function saveMessage(msg) {
  if (!savingEnabled) return;
  const tx = db.transaction("messages", "readwrite");
  const store = tx.objectStore("messages");
  store.put(msg);
}

function deleteMessage(id) {
  if (!savingEnabled) return;
  const tx = db.transaction("messages", "readwrite");
  const store = tx.objectStore("messages");
  store.delete(id);
  loadAndRenderMessages();
}

function handleIncoming(msg) {
  msg.id = `${msg.name}_${msg.time}`;
  if (!savingEnabled) return renderMessages([msg]);

  const tx = db.transaction("messages", "readwrite");
  const store = tx.objectStore("messages");
  const getReq = store.get(msg.id);

  getReq.onsuccess = () => {
    const existing = getReq.result;
    if (existing) {
      if (msg.message) existing.message = msg.message;
      if (msg.image) existing.image = msg.image;
      store.put(existing);
    } else {
      store.put(msg);
    }
    loadAndRenderMessages();
  };
}

function renderMessages(messages) {
  const container = document.getElementById('messages');
  let should_scroll_to_newest = (container.scrollHeight - container.scrollTop) > 20;

  container.innerHTML = "";
  const chat_messages = document.createElement("div");
  chat_messages.classList.add("chat-messages");
  messages.sort((a, b) => a.time - b.time);

  messages.forEach(msg => {
    getUser(msg.name).then(user => {
      const m_cont_obj = document.createElement('div');
      m_cont_obj.classList.add("message-container")
      
      const m_obj = document.createElement('div');
      m_obj.classList.add("message")

      if (currentUser && msg.name == currentUser.username) m_cont_obj.classList.add("user");

      m_obj.innerHTML = `
      <p class="message-header">
        <strong>@${msg.name}</strong> 
        <span class="timestamp">${new Date(msg.time).toLocaleTimeString()}</span>
      </p>
      `;

      if (msg.image) {
        const img = document.createElement('img');
        img.src = msg.image;
        m_obj.appendChild(img);
      }
      if (msg.message) {
        const p = document.createElement('p');
        p.textContent = msg.message;
        m_obj.appendChild(p);
      }
      
      m_cont_obj.appendChild(m_obj)

      if (savingEnabled) {
        const btn = document.createElement('button');
        btn.textContent = "🗑 Delete";
        btn.onclick = () => deleteMessage(msg.id);
        m_cont_obj.appendChild(btn)
      }
      chat_messages.appendChild(m_cont_obj);
    });
  });
  container.appendChild(chat_messages);

  if (should_scroll_to_newest) container.scrollTop = container.scrollHeight;
  console.log(should_scroll_to_newest, container.scrollTop, container.scrollHeight)
  
}

socket.onmessage = async (event) => {
  const raw = await event.data.text();
  const msg = JSON.parse(raw);
  handleIncoming(msg);
};

const input = document.getElementById('msgInput');

input.addEventListener('keydown', function(event) {
  if (event.key === 'Enter' && !event.shiftKey && !event.altKey && !event.ctrlKey) {
    event.preventDefault();
    sendMessage();
  }
});

function sendMessage() {
  if (!currentUser || socket.readyState !== WebSocket.OPEN || !input.value) return;

  const msg = {
    name: currentUser.username,
    message: input.value,
    time: Date.now(),
    image: null
  };
  socket.send(JSON.stringify(msg));
  input.value = "";
}

function sendImage() {
  const file = document.getElementById('imgInput').files[0];
  if (!currentUser || !file || socket.readyState !== WebSocket.OPEN) return;

  const reader = new FileReader();
  reader.onload = () => {
    const msg = {
      name: currentUser.username,
      message: "",
      image: reader.result,
      time: Date.now()
    };
    socket.send(JSON.stringify(msg));
  };
  reader.readAsDataURL(file);
}

function shareMessages() {
  if (!currentUser || !savingEnabled) return alert("Cannot share — not logged in or saving unavailable.");
  const tx = db.transaction("messages", "readonly");
  const store = tx.objectStore("messages");
  const req = store.getAll();
  req.onsuccess = () => {
    req.result.forEach(m => socket.send(JSON.stringify(m)));
  };
}
</script>
</body>
</html>